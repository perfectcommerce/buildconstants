package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"go/format"
	"io"
	"os"
	"os/exec"
	"path"
	"strings"
	"text/template"
)

const (
	templatePrelude = `// Generated by running
//      buildconstants
// DO NOT EDIT

package {{.GOPKG}}

// generated constants
const (
	MustRunBuildConstants = 0

`

	templatePostlude = ")"
)

type cmdReader struct {
	scanner   *bufio.Scanner
	separator string
}

// newCmdReader creates a cmdReader for making cmds from r
func newCmdReader(r io.Reader, sep string) *cmdReader {
	return &cmdReader{scanner: bufio.NewScanner(r), separator: sep}
}

// read creates the cmds from the reader originally passed in.
//   Each cmd will be separated from their Line by the r's sep.
func (r cmdReader) read() ([]cmd, error) {
	var cmds []cmd
	for r.scanner.Scan() {
		k, v, err := lineSplit(r.scanner.Text(), r.separator)
		if err != nil {
			continue
		}
		c := parseCmd(k, v)
		cmds = append(cmds, c)
	}
	return cmds, nil
}

// lineSplit splits the line by sep, err on invalid lines
func lineSplit(line, sep string) (string, string, error) {
	splits := strings.Split(line, sep)
	if len(splits) < 2 {
		return "", "", errors.New("invalid line")
	}
	rest := strings.TrimSpace(strings.Join(splits[1:], " "))
	return splits[0], rest, nil
}

// parseCmd builds a cmd from the key and val, and checks if it is just an
//   environment variable or a command
func parseCmd(key, val string) cmd {
	return cmd{
		Var:  strings.TrimSpace(key),
		Line: val,
		echo: isEnvVar(val),
	}
}

// isEnvVar checks if s looks like an environment variable
func isEnvVar(s string) bool {
	return strings.HasPrefix(s, "$")
}

type cmd struct {
	Var  string
	Line string
	echo bool // get value from env
}

// read commands from a text file.  Each command has its own line
//   and the lines are of the form `VAR = echo $FOO`
//   where $VAR is the env variable and everything after '=' will be evaluated for the value
func cmdRead(cmdfile string) ([]cmd, error) {

	f, err := os.Open(cmdfile)
	if err != nil {
		return []cmd{}, err
	}
	defer f.Close()

	cr := newCmdReader(f, "=")
	return cr.read()
}

// envTemplate builds the template string of the environment variables.
//  It needs to be in the same order in case a later command depends on
//  the value of a previous command
func envTemplate(ins []cmd) string {
	var s string
	for _, in := range ins {
		s = s + " " + in.Var + " = \"{{." + in.Var + "}}\"\n"
	}
	return s
}

// do the cmd by expanding in the shell and running (as needed)
func do(command cmd) (string, error) {
	expanded := os.Expand(command.Line, os.Getenv)
	var out string
	if command.echo {
		out = expanded
	} else {
		split := strings.Split(expanded, " ")
		cmd := exec.Command(split[0], split[1:]...)
		bout, err := cmd.Output()
		if err != nil {
			return "", err
		}
		out = string(bout)
	}

	val := strings.TrimSpace(out)
	err := os.Setenv(command.Var, val)
	if err != nil {
		return "", err
	}
	return val, nil
}

// get current package's name
func pkg() string {
	pkgCmd := exec.Command("go", "list", ".")
	out, err := pkgCmd.Output()
	if err != nil {
		return "main"
	}
	_, packageName := path.Split(strings.TrimSpace(string(out)))
	return packageName
}

func main() {

	cmdfile := flag.String("i", "commands.txt", "file of commands to be run")
	fname := flag.String("o", "", "output file")
	packageName := flag.String("package", pkg(), "package the generated file will be in.")
	flag.Parse()

	incmds, err := cmdRead(*cmdfile)
	if err != nil {
		os.Exit(1)
	}

	outcmds := make(map[string]string, len(incmds)+1) //since we add GOPKG
	outcmds["GOPKG"] = *packageName

	for _, cmd := range incmds {
		val, err := do(cmd)
		if err != nil {
			val = ""
		}
		outcmds[cmd.Var] = val
	}

	templ := templatePrelude + envTemplate(incmds) + templatePostlude

	t := template.Must(template.New("templ").Parse(templ))

	var buf bytes.Buffer
	err = t.Execute(&buf, outcmds)
	if err != nil {
		os.Exit(1)
	}
	fmted, err := format.Source(buf.Bytes())
	if err != nil {
		os.Exit(1)
	}

	f := os.Stdout
	if *fname != "" {
		f, err = os.Create(*fname)
		if err != nil {
			os.Exit(1)
		}
	}
	defer f.Close()
	f.Write(fmted)
}
